#!/bin/bash
# sbx-manager - sing-box management tool with backup/export integration
# Generated by sbx-lite installer

# Strict mode: exit on error, undefined variables, pipe failures
set -euo pipefail

# Module paths
LIB_DIR="${LIB_DIR:-/usr/local/lib/sbx}"

# Color definitions
G='\033[0;32m'
Y='\033[0;33m'
R='\033[0;31m'
B='\033[1m'
CYAN='\033[0;36m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
N='\033[0m'

# Load modules if available (graceful degradation)
if [[ -d "$LIB_DIR" ]]; then
    # shellcheck source=/dev/null
    [[ -f "$LIB_DIR/common.sh" ]] && source "$LIB_DIR/common.sh"
    # shellcheck source=/dev/null
    [[ -f "$LIB_DIR/backup.sh" ]] && source "$LIB_DIR/backup.sh"
    # shellcheck source=/dev/null
    [[ -f "$LIB_DIR/export.sh" ]] && source "$LIB_DIR/export.sh"
fi

# Simple logo for management tool
show_sbx_logo() {
  echo
  echo -e "${B}${CYAN}█▀▀ █▄▄ ▀▄▀   █▀▄▀█ ▄▀█ █▄ █ ▄▀█ █▀▀ █▀▀ █▀█${N}"
  echo -e "${B}${BLUE}▄██ █▄█  █    █ ▀ █ █▀█ █ ▀█ █▀█ █▄█ ██▄ █▀▄${N}"
  echo -e "${G}================================================${N}"
  echo
}

# Show usage information
show_usage() {
    cat <<EOF
${B}sbx-manager${N} - sing-box management tool

${B}Usage:${N}
  sbx ${G}<command>${N} [options]

${B}Service Management:${N}
  status              Show service status
  start               Start sing-box service
  stop                Stop sing-box service
  restart             Restart sing-box service
  log|logs            Show live logs (Ctrl+C to exit)
  check               Validate configuration file

${B}Configuration:${N}
  info|show           Show configuration and URIs
  qr                  Display QR codes for client import

${B}Backup & Restore:${N}
  backup create [--encrypt]         Create backup (optionally encrypted)
  backup list                       List available backups
  backup restore <file> [password]  Restore from backup
  backup cleanup                    Delete old backups (30+ days)

${B}Configuration Export:${N}
  export v2rayn [protocol] [file]   Export v2rayN config (reality|ws)
  export clash [file]               Export Clash YAML config
  export uri [protocol]             Export share URIs (reality|ws|hy2|all)
  export qr [output-dir]            Generate QR code images
  export subscription [file]        Generate subscription link

${B}System:${N}
  uninstall|remove    Complete uninstall (requires root)
  help                Show this help message

${B}Examples:${N}
  sbx info                                  # Show all configuration
  sbx backup create --encrypt               # Create encrypted backup
  sbx backup restore /var/backups/sbx/...  # Restore from backup
  sbx export v2rayn reality > config.json   # Export v2rayN config
  sbx export clash > clash.yaml             # Export Clash config
  sbx export qr ./qr-codes/                 # Generate QR codes

EOF
}

CLIENT_INFO_PATH="${CLIENT_INFO:-/etc/sing-box/client-info.txt}"
CLIENT_INFO_ALLOWED_KEYS_REGEX="^(DOMAIN|UUID|PUBLIC_KEY|SHORT_ID|SNI|REALITY_PORT|WS_PORT|HY2_PORT|HY2_PASS|CERT_FULLCHAIN|CERT_KEY)$"

error_exit() {
    echo -e "${R}[ERR]${N} $1" >&2
    exit "${2:-1}"
}

validate_client_info_file() {
    local client_info_file="$1"
    [[ -n "$client_info_file" ]] || error_exit "Client info path is empty."
    [[ -f "$client_info_file" ]] || error_exit "Client info not found: $client_info_file"
    [[ ! -L "$client_info_file" ]] || error_exit "Refusing to load client info from symlink: $client_info_file"

    local resolved owner perm
    resolved=$(readlink -f "$client_info_file") || error_exit "Failed to resolve client info path: $client_info_file"
    owner=$(stat -c '%u' "$resolved") || error_exit "Unable to read client info ownership."
    perm=$(stat -c '%a' "$resolved") || error_exit "Unable to read client info permissions."

    [[ "$owner" -eq 0 ]] || error_exit "Client info must be owned by root (uid 0)."
    [[ "$perm" == "600" ]] || error_exit "Client info permissions must be 600 (found $perm)."
    [[ -s "$resolved" ]] || error_exit "Client info is empty."

    echo "$resolved"
}

parse_client_info_file() {
    local file="$1"
    local invalid_line checksum line key value
    declare -A client_info_map=()

    # Accept both KEY="value" (quoted) and KEY=value (unquoted) formats
    invalid_line=$(grep -nEv '^[[:space:]]*(#.*)?$|^[A-Z0-9_]+=(\"[^\"]*\"|[^[:space:]]*)[[:space:]]*$' "$file" | head -n1 || true)
    [[ -z "$invalid_line" ]] || error_exit "Invalid client info format at ${invalid_line%%:*}: ${invalid_line#*:}"

    checksum=$(sha256sum "$file" | awk '{print $1}')
    CLIENT_INFO_CHECKSUM="$checksum"

    while IFS= read -r line || [[ -n "$line" ]]; do
        [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
        # Match quoted format: KEY="value"
        if [[ "$line" =~ ^([A-Z0-9_]+)=\"([^\"]*)\"[[:space:]]*$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
        # Match unquoted format: KEY=value
        elif [[ "$line" =~ ^([A-Z0-9_]+)=([^[:space:]]*)[[:space:]]*$ ]]; then
            key="${BASH_REMATCH[1]}"
            value="${BASH_REMATCH[2]}"
        else
            error_exit "Invalid client info entry: $line"
        fi

        [[ "$key" =~ $CLIENT_INFO_ALLOWED_KEYS_REGEX ]] || error_exit "Unexpected key '${key}' in client info."
        { [[ "$value" == *'$('* ]] || [[ "$value" == *\`* ]]; } && error_exit "Suspicious characters in value for ${key}."

        client_info_map["$key"]="$value"
    done < "$file"

    for key in "${!client_info_map[@]}"; do
        printf -v "$key" '%s' "${client_info_map[$key]}"
    done

    # Set defaults for missing variables
    local default_reality="${REALITY_PORT_DEFAULT:-443}"
    local default_sni="${SNI_DEFAULT:-www.microsoft.com}"
    local default_ws="${WS_PORT_DEFAULT:-8444}"
    local default_hy2="${HY2_PORT_DEFAULT:-8443}"

    REALITY_PORT="${REALITY_PORT:-$default_reality}"
    SNI="${SNI:-$default_sni}"
    WS_PORT="${WS_PORT:-$default_ws}"
    HY2_PORT="${HY2_PORT:-$default_hy2}"
}

fallback_load_client_info() {
    local target_file="${TEST_CLIENT_INFO:-$CLIENT_INFO_PATH}"
    local resolved
    resolved=$(validate_client_info_file "$target_file")
    parse_client_info_file "$resolved"
}

ensure_client_info_loaded() {
    if command -v load_client_info >/dev/null 2>&1; then
        load_client_info
    else
        fallback_load_client_info
    fi
}

case "${1:-}" in
    status)
        echo -e "${B}=== Service Status ===${N}"
        echo "[sing-box]"
        systemctl is-active --quiet sing-box && echo -e "Status: ${G}Running${N}" || echo -e "Status: ${R}Stopped${N}"
        echo "PID: $(systemctl show -p MainPID --value sing-box)"
        echo
        systemctl status sing-box --no-pager | head -10
        ;;

    info|show)
        ensure_client_info_loaded
        show_sbx_logo

        # Validate required fields
        missing_fields=()
        has_warnings=0
        [[ -z "${PUBLIC_KEY:-}" ]] && missing_fields+=("PUBLIC_KEY") && has_warnings=1
        [[ -z "${UUID:-}" ]] && missing_fields+=("UUID") && has_warnings=1
        [[ -z "${SHORT_ID:-}" ]] && missing_fields+=("SHORT_ID") && has_warnings=1
        [[ -z "${DOMAIN:-}" ]] && missing_fields+=("DOMAIN") && has_warnings=1

        echo
        printf "${B}=== sing-box Configuration ===${N}\n"

        # Display warnings if any fields are missing
        if [[ $has_warnings -eq 1 ]]; then
            echo
            echo -e "${R}[WARNING]${N} Missing required fields in client-info.txt:"
            for field in "${missing_fields[@]}"; do
                echo -e "  ${R}✗${N} $field"
            done
            echo
            echo -e "${Y}[INFO]${N} Generated URIs may be invalid or incomplete."
            echo -e "${Y}[INFO]${N} Please run: ${B}bash install.sh${N} to reinstall."
            echo
        fi

        echo "Domain    : ${DOMAIN:-N/A}"
        echo "Binary    : /usr/local/bin/sing-box"
        echo "Config    : /etc/sing-box/config.json"
        echo "Service   : systemctl status sing-box"
        echo

        # Reality (use defaults if not set)
        REALITY_PORT="${REALITY_PORT:-443}"
        SNI="${SNI:-www.microsoft.com}"
        echo "INBOUND   : VLESS-REALITY  ${REALITY_PORT}/tcp"
        echo "  PublicKey = ${PUBLIC_KEY:-[MISSING]}"
        echo "  Short ID  = ${SHORT_ID:-[MISSING]}"
        echo "  UUID      = ${UUID:-[MISSING]}"
        URI_REAL="vless://${UUID:-}@${DOMAIN:-}:${REALITY_PORT}?encryption=none&security=reality&flow=xtls-rprx-vision&sni=${SNI}&pbk=${PUBLIC_KEY:-}&sid=${SHORT_ID:-}&type=tcp&fp=chrome#Reality-${DOMAIN:-}"
        echo "  URI       = ${URI_REAL}"

        # Warn if URI has empty parameters
        if echo "$URI_REAL" | grep -qE 'pbk=&|pbk=$|@:|//:'; then
            echo -e "  ${R}⚠ WARNING:${N} URI has empty parameters and cannot be used"
        fi

        # WebSocket (if cert exists)
        if [[ -n "${CERT_FULLCHAIN:-}" && -n "${CERT_KEY:-}" ]]; then
            WS_PORT="${WS_PORT:-8444}"
            HY2_PORT="${HY2_PORT:-8443}"
            HY2_PASS="${HY2_PASS:-}"
            echo
            echo "INBOUND   : VLESS-WS-TLS   ${WS_PORT}/tcp"
            echo "  CERT     = ${CERT_FULLCHAIN}"
            URI_WS="vless://${UUID:-}@${DOMAIN:-}:${WS_PORT}?encryption=none&security=tls&type=ws&host=${DOMAIN:-}&path=/ws&sni=${DOMAIN:-}&fp=chrome#WS-TLS-${DOMAIN:-}"
            echo "  URI      = ${URI_WS}"
            echo
            echo "INBOUND   : Hysteria2      ${HY2_PORT}/udp"
            echo "  CERT     = ${CERT_FULLCHAIN}"
            URI_HY2="hysteria2://${HY2_PASS}@${DOMAIN:-}:${HY2_PORT}/?sni=${DOMAIN:-}&alpn=h3&insecure=0#Hysteria2-${DOMAIN:-}"
            echo "  URI      = ${URI_HY2}"
        fi
        echo
        echo -e "${Y}Notes${N}: Reality/Hy2 suggest gray cloud; WS-TLS can use gray/orange cloud."

        # Optional: Generate QR codes
        if command -v qrencode >/dev/null 2>&1; then
            echo
            echo -e "${CYAN}Commands:${N}"
            echo -e "  ${G}sbx qr${N}         - Show QR codes"
            echo -e "  ${G}sbx export qr${N}  - Save QR code images"
        fi
        ;;

    qr)
        if ! command -v qrencode >/dev/null 2>&1; then
        echo -e "${R}[ERR]${N} qrencode not installed. Install with: apt install qrencode"
        exit 1
    fi

    ensure_client_info_loaded

        echo -e "${B}=== Configuration QR Codes ===${N}"

        # Generate Reality QR code
        if [[ -n "$UUID" && -n "$DOMAIN" && -n "$PUBLIC_KEY" && -n "$SHORT_ID" ]]; then
            echo
            echo -e "${G}VLESS-REALITY:${N}"
            echo "┌─────────────────────────────────────┐"
            # Use export_uri() if available (DRY), otherwise generate inline
            if command -v export_uri >/dev/null 2>&1; then
                URI_REAL=$(export_uri reality)
            else
                # Fallback: inline URI generation
                URI_REAL="vless://${UUID}@${DOMAIN}:${REALITY_PORT}?encryption=none&security=reality&flow=xtls-rprx-vision&sni=${SNI}&pbk=${PUBLIC_KEY}&sid=${SHORT_ID}&type=tcp&fp=chrome#Reality-${DOMAIN}"
            fi
            qrencode -t UTF8 -m 0 "$URI_REAL" 2>/dev/null || echo "QR code generation failed"
            echo "└─────────────────────────────────────┘"
        fi

        # Generate WS-TLS QR code if certificates exist
        if [[ -n "$CERT_FULLCHAIN" && -n "$CERT_KEY" && -n "$UUID" && -n "$DOMAIN" ]]; then
            echo
            echo -e "${G}VLESS-WS-TLS:${N}"
            echo "┌─────────────────────────────────────┐"
            if command -v export_uri >/dev/null 2>&1; then
                URI_WS=$(export_uri ws)
            else
                URI_WS="vless://${UUID}@${DOMAIN}:${WS_PORT}?encryption=none&security=tls&type=ws&host=${DOMAIN}&path=/ws&sni=${DOMAIN}&fp=chrome#WS-TLS-${DOMAIN}"
            fi
            qrencode -t UTF8 -m 0 "$URI_WS" 2>/dev/null || echo "QR code generation failed"
            echo "└─────────────────────────────────────┘"

            echo
            echo -e "${G}Hysteria2:${N}"
            echo "┌─────────────────────────────────────┐"
            if command -v export_uri >/dev/null 2>&1; then
                URI_HY2=$(export_uri hy2)
            else
                URI_HY2="hysteria2://${HY2_PASS}@${DOMAIN}:${HY2_PORT}/?sni=${DOMAIN}&alpn=h3&insecure=0#Hysteria2-${DOMAIN}"
            fi
            qrencode -t UTF8 -m 0 "$URI_HY2" 2>/dev/null || echo "QR code generation failed"
            echo "└─────────────────────────────────────┘"
        fi

        echo
        echo -e "${Y}Tip${N}: Use phone to scan QR code to import proxy configuration"
        ;;

    backup)
        if ! command -v backup_create >/dev/null 2>&1; then
            echo -e "${R}[ERR]${N} Backup module not loaded. Please reinstall sbx-lite."
            exit 1
        fi

        case "${2:-}" in
            create)
                encrypt_flag="false"
                [[ "${3:-}" == "--encrypt" ]] && encrypt_flag="true"
                backup_create "${encrypt_flag}"
                ;;
            list)
                backup_list
                ;;
            restore)
                [[ -n "${3:-}" ]] || {
                    echo -e "${R}[ERR]${N} Usage: sbx backup restore <backup-file> [password]"
                    exit 1
                }
                backup_restore "$3" "${4:-}"
                ;;
            cleanup)
                backup_cleanup
                ;;
            *)
                echo -e "${Y}Usage:${N}"
                echo "  sbx backup create [--encrypt]     - Create new backup"
                echo "  sbx backup list                   - List available backups"
                echo "  sbx backup restore <file> [pass]  - Restore from backup"
                echo "  sbx backup cleanup                - Delete old backups"
                exit 1
                ;;
        esac
        ;;

    export)
        if ! command -v export_config >/dev/null 2>&1; then
            echo -e "${R}[ERR]${N} Export module not loaded. Please reinstall sbx-lite."
            exit 1
        fi

        case "${2:-}" in
            v2rayn|v2rayng)
                export_config v2rayn "${3:-reality}" "${4:-}"
                ;;
            clash|clash-meta)
                export_config clash "" "${3:-}"
                ;;
            uri)
                export_uri "${3:-all}"
                ;;
            qr)
                export_qr_codes "${3:-./qr-codes}"
                ;;
            subscription|sub)
                export_subscription "${3:-/var/www/html/subscription.txt}"
                ;;
            *)
                echo -e "${Y}Usage:${N}"
                echo "  sbx export v2rayn [reality|ws] [file]  - Export v2rayN config"
                echo "  sbx export clash [file]                - Export Clash config"
                echo "  sbx export uri [protocol]              - Export share URIs"
                echo "  sbx export qr [output-dir]             - Generate QR codes"
                echo "  sbx export subscription [file]         - Generate subscription"
                exit 1
                ;;
        esac
        ;;

    restart)
        if systemctl restart sing-box; then
            sleep 1
            if systemctl is-active --quiet sing-box; then
                echo -e "${G}✓${N} Service restarted"
                echo -e "Status: ${G}Running${N}"
            else
                echo -e "Status: ${R}Failed${N}"
                exit 1
            fi
        else
            echo -e "${R}✗${N} Failed to restart service"
            exit 1
        fi
        ;;

    start)
        if systemctl start sing-box; then
            if systemctl is-active --quiet sing-box; then
                echo -e "${G}✓${N} Service started"
            else
                echo -e "${R}✗${N} Service not running"
                exit 1
            fi
        else
            echo -e "${R}✗${N} Failed to start service"
            exit 1
        fi
        ;;

    stop)
        if systemctl stop sing-box; then
            echo -e "${Y}✓${N} Service stopped"
        else
            echo -e "${R}✗${N} Failed to stop service"
            exit 1
        fi
        ;;

    log|logs)
        echo -e "${CYAN}Live logs (Ctrl+C to exit):${N}"
        journalctl -u sing-box -f
        ;;

    check)
        echo -e "${CYAN}Checking configuration...${N}"
        /usr/local/bin/sing-box check -c /etc/sing-box/config.json && \
            echo -e "${G}✓ Configuration valid${N}" || \
            echo -e "${R}✗ Configuration invalid${N}"
        ;;

    uninstall|remove)
        # Check if running as root
        if [[ "$(id -u)" -ne 0 ]]; then
            echo -e "${R}[ERR]${N} Please run as root (sudo sbx uninstall)"
            exit 1
        fi

        # Paths
        SB_BIN="/usr/local/bin/sing-box"
        SB_CONF_DIR="/etc/sing-box"
        SB_CONF="${SB_CONF_DIR}/config.json"
        SB_SVC="/etc/systemd/system/sing-box.service"
        CERT_DIR_BASE="/etc/ssl/sbx"

        echo
        echo -e "${Y}[!]${N} The following will be completely removed:"
        [[ -x "$SB_BIN" ]] && echo "  - Binary: $SB_BIN"
        [[ -f "$SB_CONF" ]] && echo "  - Config: $SB_CONF"
        [[ -d "$SB_CONF_DIR" ]] && echo "  - Config directory: $SB_CONF_DIR"
        [[ -f "$SB_SVC" ]] && echo "  - Service: $SB_SVC"
        [[ -x "/usr/local/bin/sbx-manager" ]] && echo "  - Management commands: sbx-manager, sbx"
        [[ -d "$CERT_DIR_BASE" ]] && echo "  - Certificates: $CERT_DIR_BASE"
        [[ -d "$LIB_DIR" ]] && echo "  - Library modules: $LIB_DIR"

        echo
        read -rp "Continue with complete removal? [y/N] " confirm
        if [[ ! "${confirm:-N}" =~ ^[Yy]$ ]]; then
            echo "Uninstall cancelled."
            exit 0
        fi

        echo
        echo -e "${G}[*]${N} Stopping and disabling sing-box service..."
        systemctl disable --now sing-box 2>/dev/null || true

        # Wait for service to stop
        retry=0
        while systemctl is-active sing-box >/dev/null 2>&1 && [[ ${retry} -lt 10 ]]; do
            sleep 1
            ((retry++))
        done

        echo -e "${G}[*]${N} Removing files..."
        rm -f "$SB_BIN" "$SB_SVC" "/usr/local/bin/sbx-manager" "/usr/local/bin/sbx"
        rm -rf "$SB_CONF_DIR" "$CERT_DIR_BASE" "$LIB_DIR"

        systemctl daemon-reload

        echo
        echo -e "${G}✓${N} sing-box uninstalled successfully"
        ;;

    help|--help|-h|"")
        # Show help for: sbx help, sbx --help, sbx -h, or just sbx (no args)
        show_usage
        exit 0
        ;;

    *)
        # Unknown command provided
        echo -e "${R}[ERR]${N} Unknown command: ${1}"
        echo
        show_usage
        exit 1
        ;;
esac
